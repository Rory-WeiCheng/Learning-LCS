import lcs_class_state_dep_vel
import lcs.optim as opt
import numpy as np
import scipy
import time
import pdb


# start_time = time.time()
################################################# load data ############################################################
x_batch_list = []
u_batch_list = []
res_batch_list = []

x_model_AB_list = []
x_model_lcs_list = []
x_next_true_list = []
lam_batch_list = []

D_list = []
d_list = []
E_list = []
F_list = []
H_list = []
c_list = []

n_state = 19
n_control = 3
n_lam = 12
# dimension of the learning residual, we only learn the velocity part, set it to be n_state = 19 if full residual is needed
n_vel = 9

# load the data, should be improved in the futrue
# 100 single push data, 10 data points per push for sample dt = 0.1
# 20 single push data, 100 data points per push for sample dt = 0.01
# change 20 to 100 if dt changes from 0.01 to 0.1
for i in range(20):
    # The state and input data
    log_num = "{:02}".format(i)
    # path to the data, should modify locally
    data_dir_xu = "/usr/rory-workspace/data/c3_learning/data_new/dt_001/State_Residual-{}.npz".format(log_num)
    data_train = np.load(data_dir_xu, allow_pickle=True)
    x_batch_raw = data_train['state_plant'][:-1,:]
    u_batch_raw = data_train['input'][:-1,:]
    res_batch_raw = data_train['residual']
    res_batch_raw = res_batch_raw[:,n_state-n_vel:n_state]

    x_batch_list.append(x_batch_raw)
    u_batch_list.append(u_batch_raw)
    res_batch_list.append(res_batch_raw)
    # also load the model predicted (only AB and with wrong LCS) next state and true next state
    x_next_model_AB_raw = data_train['state_model_AB'][:-1,:]
    x_next_model_AB_raw = x_next_model_AB_raw[:,n_state-n_vel:n_state]
    x_model_AB_list.append(x_next_model_AB_raw)
    x_next_true_raw = data_train['state_plant'][1:,:]
    x_next_true_raw = x_next_true_raw[:,n_state-n_vel:n_state]
    x_next_true_list.append(x_next_true_raw)
    x_model_lcs_raw = data_train['state_model'][1:,:]
    x_model_lcs_raw = x_model_lcs_raw[:,n_state-n_vel:n_state]
    x_model_lcs_list.append(x_model_lcs_raw)
    # also load the lambda generated by the wrong LCS
    # lam_batch_raw = data_train['lambda_model'][:-1,:]
    # lam_batch_list.append(lam_batch_raw)

    # Load the state-dependent (wrong) LCS matrices
    data_dir_lcs = "/usr/rory-workspace/data/c3_learning/data_new/dt_001/LCS_Matrices-{}.npz".format(log_num)
    data_lcs = np.load(data_dir_lcs, allow_pickle=True)
    D = data_lcs['D_lcs'][:-1]
    D = D[:,n_state-n_vel:n_state]
    d = data_lcs['d_lcs'][:-1]
    d = d[:,n_state-n_vel:n_state]
    E = data_lcs['E_lcs'][:-1]
    F = data_lcs['F_lcs'][:-1]
    H = data_lcs['H_lcs'][:-1]
    c = data_lcs['c_lcs'][:-1]
    D_list.append(D)
    d_list.append(d)
    E_list.append(E)
    H_list.append(H)
    F_list.append(F)
    c_list.append(c)

# concatenate as numpy array
# x_batch: (num_data, num_state)
# u_batch: (num_data, num_control)
# res_batch: (num_data, num_vel)
x_batch = np.concatenate(x_batch_list,axis=0)
u_batch = np.concatenate(u_batch_list,axis=0)
res_batch = np.concatenate(res_batch_list,axis=0)

# x_model_AB: (num_data, num_vel)
# x_model_lcs: (num_data, num_vel)
# x_next_true: (num_data, num_vel)
# lam_batch: (num_data, num_lam)
x_model_AB = np.concatenate(x_model_AB_list,axis=0)
x_model_lcs = np.concatenate(x_model_lcs_list,axis=0)
x_next_true = np.concatenate(x_next_true_list,axis=0)
# lam_batch = np.concatenate(lam_batch_list,axis=0)

# A_batch: (num_data, num_vel, num_state)
# B_batch: (num_data, num_vel, num_control)
# D_batch: (num_data, num_vel, num_lam)
# d_batch: (num_data, num_vel)
A_batch = np.zeros((x_batch.shape[0],n_vel,n_state))
B_batch = np.zeros((x_batch.shape[0],n_vel,n_control))
D_batch = np.concatenate(D_list,axis=0)
d_batch = np.zeros((x_batch.shape[0],n_vel))

# E_batch: (num_data, num_lam, num_state)
# F_batch: (num_data, num_lam, num_lam)
# H_batch: (num_data, num_lam, num_control)
# c_batch: (num_data, num_lam)
E_batch = np.concatenate(E_list,axis=0)
F_batch = np.concatenate(F_list,axis=0)
H_batch = np.concatenate(H_list,axis=0)
c_batch = np.concatenate(c_list,axis=0)

########################################## experimental sanity checking ################################################
lam_list = []

for i in range(len(D_batch)):
    lam = np.linalg.lstsq(D_batch[i],res_batch[i],rcond=None)[0]
    lam_list.append(lam)

index_list = []
z_list = []
for i in range(len(lam_list)):
    lam = lam_list[i]
    if lam[2]>0.1:
        index_list.append(i)
        z = E_batch[i] @ x_batch[i] + H_batch[i] @ u_batch[i] + F_batch[i] @ lam + c_batch[i]
        z = z[2]
        z_list.append(z)

phi = -np.mean(z_list)
print(phi)

pdb.set_trace()

