"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

try:
    import cStringIO.StringIO as BytesIO
except ImportError:
    from io import BytesIO
import struct

class lcmt_learning_data(object):
    __slots__ = ["utime", "settling_time", "num_state", "num_velocity", "num_control", "num_lambda", "A", "B", "D", "d", "E", "F", "H", "c", "state", "input", "state_pred"]

    __typenames__ = ["int64_t", "double", "int16_t", "int16_t", "int16_t", "int16_t", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double"]

    __dimensions__ = [None, None, None, None, None, None, ["num_velocity", "num_state"], ["num_velocity", "num_control"], ["num_velocity", "num_lambda"], ["num_velocity"], ["num_lambda", "num_state"], ["num_lambda", "num_lambda"], ["num_lambda", "num_control"], ["num_lambda"], ["num_state"], ["num_control"], ["num_velocity"]]

    def __init__(self):
        self.utime = 0
        self.settling_time = 0.0
        self.num_state = 0
        self.num_velocity = 0
        self.num_control = 0
        self.num_lambda = 0
        self.A = []
        self.B = []
        self.D = []
        self.d = []
        self.E = []
        self.F = []
        self.H = []
        self.c = []
        self.state = []
        self.input = []
        self.state_pred = []

    def encode(self):
        buf = BytesIO()
        buf.write(lcmt_learning_data._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">qdhhhh", self.utime, self.settling_time, self.num_state, self.num_velocity, self.num_control, self.num_lambda))
        for i0 in range(self.num_velocity):
            buf.write(struct.pack('>%dd' % self.num_state, *self.A[i0][:self.num_state]))
        for i0 in range(self.num_velocity):
            buf.write(struct.pack('>%dd' % self.num_control, *self.B[i0][:self.num_control]))
        for i0 in range(self.num_velocity):
            buf.write(struct.pack('>%dd' % self.num_lambda, *self.D[i0][:self.num_lambda]))
        buf.write(struct.pack('>%dd' % self.num_velocity, *self.d[:self.num_velocity]))
        for i0 in range(self.num_lambda):
            buf.write(struct.pack('>%dd' % self.num_state, *self.E[i0][:self.num_state]))
        for i0 in range(self.num_lambda):
            buf.write(struct.pack('>%dd' % self.num_lambda, *self.F[i0][:self.num_lambda]))
        for i0 in range(self.num_lambda):
            buf.write(struct.pack('>%dd' % self.num_control, *self.H[i0][:self.num_control]))
        buf.write(struct.pack('>%dd' % self.num_lambda, *self.c[:self.num_lambda]))
        buf.write(struct.pack('>%dd' % self.num_state, *self.state[:self.num_state]))
        buf.write(struct.pack('>%dd' % self.num_control, *self.input[:self.num_control]))
        buf.write(struct.pack('>%dd' % self.num_velocity, *self.state_pred[:self.num_velocity]))

    def decode(data):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != lcmt_learning_data._get_packed_fingerprint():
            raise ValueError("Decode error")
        return lcmt_learning_data._decode_one(buf)
    decode = staticmethod(decode)

    def _decode_one(buf):
        self = lcmt_learning_data()
        self.utime, self.settling_time, self.num_state, self.num_velocity, self.num_control, self.num_lambda = struct.unpack(">qdhhhh", buf.read(24))
        self.A = []
        for i0 in range(self.num_velocity):
            self.A.append(struct.unpack('>%dd' % self.num_state, buf.read(self.num_state * 8)))
        self.B = []
        for i0 in range(self.num_velocity):
            self.B.append(struct.unpack('>%dd' % self.num_control, buf.read(self.num_control * 8)))
        self.D = []
        for i0 in range(self.num_velocity):
            self.D.append(struct.unpack('>%dd' % self.num_lambda, buf.read(self.num_lambda * 8)))
        self.d = struct.unpack('>%dd' % self.num_velocity, buf.read(self.num_velocity * 8))
        self.E = []
        for i0 in range(self.num_lambda):
            self.E.append(struct.unpack('>%dd' % self.num_state, buf.read(self.num_state * 8)))
        self.F = []
        for i0 in range(self.num_lambda):
            self.F.append(struct.unpack('>%dd' % self.num_lambda, buf.read(self.num_lambda * 8)))
        self.H = []
        for i0 in range(self.num_lambda):
            self.H.append(struct.unpack('>%dd' % self.num_control, buf.read(self.num_control * 8)))
        self.c = struct.unpack('>%dd' % self.num_lambda, buf.read(self.num_lambda * 8))
        self.state = struct.unpack('>%dd' % self.num_state, buf.read(self.num_state * 8))
        self.input = struct.unpack('>%dd' % self.num_control, buf.read(self.num_control * 8))
        self.state_pred = struct.unpack('>%dd' % self.num_velocity, buf.read(self.num_velocity * 8))
        return self
    _decode_one = staticmethod(_decode_one)

    def _get_hash_recursive(parents):
        if lcmt_learning_data in parents: return 0
        tmphash = (0xea2dc562eee4b07f) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff) + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _get_hash_recursive = staticmethod(_get_hash_recursive)
    _packed_fingerprint = None

    def _get_packed_fingerprint():
        if lcmt_learning_data._packed_fingerprint is None:
            lcmt_learning_data._packed_fingerprint = struct.pack(">Q", lcmt_learning_data._get_hash_recursive([]))
        return lcmt_learning_data._packed_fingerprint
    _get_packed_fingerprint = staticmethod(_get_packed_fingerprint)

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", lcmt_learning_data._get_packed_fingerprint())[0]

